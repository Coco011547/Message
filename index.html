
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IMS Activities Excel Formatter – VVM Header & Auto Date</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Segoe UI, Roboto, Arial, sans-serif; margin: 24px; line-height: 1.5; }
    h1 { font-size: 1.4rem; margin: 0 0 8px; }
    h2 { font-size: 1.1rem; margin-top: 24px; }
    label { display:block; margin: 12px 0 4px; font-weight: 600; }
    input[type="text"], input[type="date"], select, textarea { width: 100%; max-width: 720px; padding: 8px; font-size: 14px; }
    textarea { height: 160px; }
    button { padding: 8px 12px; margin-right: 8px; }
    .mono { font-family: Consolas, "Liberation Mono", "Courier New", monospace; }
    .muted { color:#666; }
    .output { white-space: pre-wrap; border: 1px solid #ddd; padding: 12px; border-radius: 6px; background: #fafafa; }
    .small { font-size: 12px; }
    .row { display:flex; gap:16px; flex-wrap:wrap; }
    .col { flex: 1 1 320px; }
  </style>
</head>
<body>
  <h1>IMS Activities Excel Formatter – VVM Header & Auto Date</h1>
  <p class="muted small">
    Upload CSV/TSV/TXT or paste tabular text. Rows with “Cancelled” in any Status (J/K) are excluded from details.
    When Status = Completed, header lists unique PE Categories from column L (excluding “NSA”). Dates auto-fill based on status.
  </p>

  <!-- 1) Input -->
  <h2>1) Input</h2>
  <label for="dateInput">Date (auto-changes with Status; you can override):</label>
  <input id="dateInput" type="date" />

  <label for="fileInput">CSV/TSV/TXT file</label>
  <input id="fileInput" type="file" />

  <label for="sheetName">Sheet name (optional; ignored for CSV/TSV/TXT)</label>
  <input id="sheetName" type="text" placeholder="e.g., Sheet1" />

  <label for="gridText">OR paste grid text (Row1 headers must include "Node Type", "PE Purpose"; optional "Status" (J/K), "PE Category" (L))</label>
  <textarea id="gridText" class="mono" placeholder="Node Type,PE Purpose,Status J,Status K,PE Category&#10;MSC,Integration,Completed,,Core"></textarea>

  <label for="fontColorFilter">Font-color filter:</label>
  <select id="fontColorFilter">
    <option value="black-only">Include only Node Type cells with Black / Automatic font</option>
    <option value="all">Include all rows (ignore font color)</option>
  </select>

  <label for="statusSelect">Status:</label>
  <select id="statusSelect">
    <option value="">---</option>
    <option value="Planned Tonight">Planned Tonight</option>
    <option value="Completed">Completed</option>
  </select>
  <div style="margin-top:8px;">
    <button id="parseFileBtn">Parse File ▶</button>
    <button id="parseTextBtn">Parse Pasted Text ▶</button>
    <button id="clearBtn">Clear</button>
  </div>

  <!-- 2) Output -->
  <h2>2) Output (Final Text)</h2>
  <div style="margin-bottom:8px;">
    <button id="copyBtn">Copy Output</button>
    <button id="downloadTxtBtn">Download .txt</button>
    <button id="downloadHtmlBtn">Download as HTML</button>
  </div>
  <div id="formattedOutput" class="output mono"></div>

  <!-- Send to WhatsApp -->
  <h2>Send to WhatsApp</h2>
  <div class="row">
    <div class="col">
      <label for="waNumber">Recipient (E.164, e.g., +9198XXXXXXXX)</label>
      <input id="waNumber" type="text" placeholder="+91XXXXXXXXXX" />
    </div>
  </div>
  <button id="sendWhatsAppBtn">Send WhatsApp</button>
  <span class="small muted">Sends via your Vercel backend using Twilio’s WhatsApp API.</span>

  <!-- Logic section (documentation) -->
  <h2>Logic</h2>
  <pre class="mono small">
Required headers: "Node Type", "PE Purpose". Optional: "Status"/"Status J"/"Status K", "PE Category" (L).
Cancelled detection: if any Status column contains "Cancelled" (case-insensitive), the row is excluded from details and counted in the header.
Normal header (non-Completed):
VVM Status {Pretty Date} completed {completedCount}/{totalCount} ({totalCount} PE Category)
{completedCount} PE's Completed, {cancelledCount} Cancelled
If Status = Completed:
PE Category (Completed): cat1, cat2, ... (unique L values for non-cancelled rows, excluding NSA; shows "—" if none)
Auto Date: Planned Tonight → today; Completed → previous day (localized to device).
  </pre>

  <script>
    /*** CONFIG: Set your Vercel API endpoint here ***/
    const API_URL = 'https://YOUR-VERCEL-PROJECT.vercel.app/api/send-message'; // TODO: replace with your real URL

    /*** Helpers ***/
    const EXCLUDED_CATEGORIES = ["NSA"];
    function excludeCategoriesCaseInsensitive(list, excluded = EXCLUDED_CATEGORIES) {
      const exSet = new Set(excluded.map(s => (s || "").trim().toLowerCase()));
      return (list || []).filter(c => {
        const val = (c || "").trim();
        return val && !exSet.has(val.toLowerCase());
      });
    }
    function todayISO(){ const d=new Date(); return d.toISOString().slice(0,10); }
    function yesterdayISO(){ const d=new Date(); d.setDate(d.getDate()-1); return d.toISOString().slice(0,10); }
    function prettyDateFromISO(iso){
      if (!iso) return "";
      const d = new Date(iso);
      return d.toLocaleDateString(undefined,{day:"2-digit",month:"short",year:"numeric"});
    }
    // CSV/TSV/semicolon-friendly parser
    function csvToRows(text){
      const lines = text.trim().split(/\r?\n/);
      return lines.map(line => {
        if (line.includes('\t')) return line.split('\t');  // tab-delimited
        if (line.includes(','))  return line.split(',');   // comma-delimited
        if (line.includes(';'))  return line.split(';');   // semicolon-delimited
        return [line]; // fallback
      });
    }
    function unique(arr){ return Array.from(new Set(arr)); }

    /*** Core formatting ***/
    function formatOutput(rows, statusSelection) {
      if (!rows || rows.length === 0) return "No rows parsed.";
      const headers = rows[0].map(h=>h.trim());
      const idx = {}; headers.forEach((h,i)=>{ idx[h]=i; });
      if (!("Node Type" in idx) || !("PE Purpose" in idx)) {
        return "Missing required headers: Node Type, PE Purpose";
      }
      const statusCols = ["Status","Status J","Status K"].filter(h=>h in idx).map(h=>idx[h]);
      const iNodeType = idx["Node Type"], iPEPurpose = idx["PE Purpose"], iPECategory = ("PE Category" in idx)?idx["PE Category"]:null;

      function isCancelled(r){ return statusCols.some(ci=>((r[ci]||"").toLowerCase().includes("cancelled"))); }
      const dataRows = rows.slice(1);
      const nonCancelled = dataRows.filter(r=>!isCancelled(r));
      const totalCount = nonCancelled.length;
      const completedCount = nonCancelled.filter(r=>statusCols.some(ci=>((r[ci]||"").toLowerCase().includes("completed")))).length;
      const cancelledCount = dataRows.length - nonCancelled.length;

      const details = nonCancelled.map(r=>`- ${(r[iNodeType]||"").trim()} — ${(r[iPEPurpose]||"").trim()} — ${statusSelection||""}`).join("\n");

      // Auto date
      const dateInput = document.getElementById("dateInput");
      let selectedDateISO = dateInput.value;
      if (!selectedDateISO) {
        if (statusSelection === "Completed") selectedDateISO = yesterdayISO();
        else if (statusSelection === "Planned Tonight") selectedDateISO = todayISO();
      }
      const prettyDate = prettyDateFromISO(selectedDateISO);

      let headerText = "";
      let printedCatLine = "";
      if (statusSelection === "Completed") {
        let categories = [];
        if (iPECategory !== null) {
          categories = nonCancelled.map(r => (r[iPECategory]||"").trim()).filter(c=>c.length>0);
        }
        const uniqueCats = unique(categories);
        const filteredCats = excludeCategoriesCaseInsensitive(uniqueCats); // NSA removed
        const catsDisplay = filteredCats.length ? filteredCats.join(", ") : "—";
        headerText = `PE Category (Completed): ${catsDisplay}\n`;

        // Printed line immediately after header (same exclusion)
        printedCatLine = (filteredCats.length ? filteredCats.join(", ") : "—") + "\n";
      } else {
        headerText = `VVM Status ${prettyDate} completed ${completedCount}/${totalCount} (${totalCount} PE Category)\n` +
                     `${completedCount} PE's Completed, ${cancelledCount} Cancelled\n`;
      }

      const summaryLine = `Summary: ${nonCancelled.length} items included.\n`;
      return headerText + printedCatLine + summaryLine + details;
    }

    /*** Wiring ***/
    const formattedOutputEl = document.getElementById("formattedOutput");
    const statusSelectEl = document.getElementById("statusSelect");
    let parsedRows = [];

    function render(){
      const statusSel = statusSelectEl.value || "";   // FIX: use actual option values
      const text = formatOutput(parsedRows, statusSel);
      formattedOutputEl.textContent = text;
    }

    document.getElementById("parseTextBtn").addEventListener("click", ()=>{
      const raw = document.getElementById("gridText").value||"";
      if (!raw.trim()) { formattedOutputEl.textContent = "Paste grid text first."; return; }
      parsedRows = csvToRows(raw);
      render();
    });

    document.getElementById("parseFileBtn").addEventListener("click", async ()=>{
      const fileEl = document.getElementById("fileInput");
      const file = fileEl.files && fileEl.files[0];
      if (!file) { formattedOutputEl.textContent = "Select a file first."; return; }
      const text = await file.text(); // supports CSV/TSV/TXT
      parsedRows = csvToRows(text);
      render();
    });

    document.getElementById("clearBtn").addEventListener("click", ()=>{
      document.getElementById("gridText").value = "";
      document.getElementById("fileInput").value = "";
      parsedRows = [];
      formattedOutputEl.textContent = "";
    });

    statusSelectEl.addEventListener("change", render);
    document.getElementById("dateInput").addEventListener("change", render);

    // Copy / download
    document.getElementById("copyBtn").addEventListener("click", async ()=>{
      const text = formattedOutputEl.textContent||"";
      try { await navigator.clipboard.writeText(text); alert("Output copied to clipboard."); } catch(e){ alert("Copy failed: "+e.message); }
    });
    function download(filename, mime, content){
      const a=document.createElement("a");
      a.href=URL.createObjectURL(new Blob([content],{type:mime}));
      a.download=filename;
      document.body.appendChild(a); a.click(); a.remove();
    }
    document.getElementById("downloadTxtBtn").addEventListener("click", ()=>{
      download("IMS_Activities_Formatted.txt","text/plain", formattedOutputEl.textContent||"");
    });
    document.getElementById("downloadHtmlBtn").addEventListener("click", ()=>{
      const text=formattedOutputEl.textContent||"";
      const html=`<!DOCTYPE html><html><head><meta charset="utf-8"><title>IMS Output</title></head><body><pre>${escapeHtml(text)}</pre></body></html>`;
      download("IMS_Activities_Formatted.html","text/html", html);
    });
    function escapeHtml(s){
      return (s||"").replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
    }

    // Send to WhatsApp via Vercel endpoint
    document.getElementById('sendWhatsAppBtn').addEventListener('click', async () => {
      const to = (document.getElementById('waNumber').value || '').trim();
      const body = document.getElementById('formattedOutput').textContent || '';
      if (!to || !body) { alert('Enter recipient and generate output first.'); return; }

      try {
        const resp = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ channel: 'whatsapp_twilio', to, body })
        });
        const data = await resp.json();
        if (!resp.ok) throw new Error(data.error || 'Failed to send');
        alert(`WhatsApp queued: ${data.id || 'OK'}`);
      } catch (e) {
        alert(`Send failed: ${e.message}`);
      }
    });

    // Initialize defaults
    document.getElementById("dateInput").value = todayISO();
  </script>
</body>
</html>
