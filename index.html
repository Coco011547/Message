
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IMS Activities Excel Formatter – VVM Header & Auto Date</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Segoe UI, Roboto, Arial, sans-serif; margin: 24px; line-height: 1.5; }
    h1 { font-size: 1.4rem; margin: 0 0 8px; }
    h2 { font-size: 1.1rem; margin-top: 24px; }
    label { display:block; margin: 12px 0 4px; font-weight: 600; }
    input[type="text"], input[type="date"], select, textarea { width: 100%; max-width: 720px; padding: 8px; font-size: 14px; }
    textarea { height: 160px; }
    button { padding: 8px 12px; margin-right: 8px; }
    .mono { font-family: Consolas, "Liberation Mono", "Courier New", monospace; }
    .muted { color:#666; }
    .output { white-space: pre-wrap; border: 1px solid #ddd; padding: 12px; border-radius: 6px; background: #fafafa; }
    .small { font-size: 12px; }
    .row { display:flex; gap:16px; flex-wrap:wrap; }
    .col { flex: 1 1 320px; }
  </style>
</head>
<body>
  <h1>IMS Activities Excel Formatter – VVM Header & Auto Date</h1>
  <p class="muted small">
    Paste CSV/TSV text or upload file. When <b>Completed</b> is selected, the header uses VVM format and includes Node Type counts and Key PE Details.
  </p>

  <!-- 1) Input -->
  <h2>1) Input</h2>
  <label for="dateInput">Date (auto-changes with Status; you can override):</label>
  <input id="dateInput" type="date" />

  <label for="fileInput">CSV/TSV/TXT file</label>
  <input id="fileInput" type="file" />

  <label for="sheetName">Sheet name (optional; ignored for CSV/TSV/TXT)</label>
  <input id="sheetName" type="text" placeholder="e.g., Sheet1" />

  <label for="gridText">OR paste grid text (Row1 headers must include "Node Type", "PE Purpose"; optional "Status" (J/K), "PE Category" (L))</label>
  <textarea id="gridText" class="mono" placeholder="Node Type,PE Purpose,Status J,Status K,PE Category&#10;MSC,Integration,Completed,,Core"></textarea>

  <label for="fontColorFilter">Font-color filter:</label>
  <select id="fontColorFilter">
    <option value="black-only">Include only Node Type cells with Black / Automatic font</option>
    <option value="all">Include all rows (ignore font color)</option>
  </select>

  <label for="statusSelect">Status:</label>
  <select id="statusSelect">
    <option value="">---</option>
    <option value="Planned Tonight">Planned Tonight</option>
    <option value="Completed">Completed</option>
  </select>
  <div style="margin-top:8px;">
    <button id="parseFileBtn">Parse File ▶</button>
    <button id="parseTextBtn">Parse Pasted Text ▶</button>
    <button id="clearBtn">Clear</button>
  </div>

  <!-- 2) Output -->
  <h2>2) Output (Final Text)</h2>
  <div style="margin-bottom:8px;">
    <button id="copyBtn">Copy Output</button>
    <button id="downloadTxtBtn">Download .txt</button>
    <button id="downloadHtmlBtn">Download as HTML</button>
  </div>
  <div id="formattedOutput" class="output mono"></div>

  <!-- Send to WhatsApp -->
  <h2>Send to WhatsApp</h2>
  <div class="row">
    <div class="col">
      <label for="waNumber">Recipient (E.164, e.g., +9198XXXXXXXX)</label>
      <input id="waNumber" type="text" placeholder="+91XXXXXXXXXX" />
    </div>
  </div>
  <button id="sendWhatsAppBtn">Send WhatsApp</button>
  <span class="small muted">Sends via your Vercel backend using Twilio’s WhatsApp API.</span>

  <!-- Logic docs -->
  <h2>Logic</h2>
  <pre class="mono small">
Required headers: "Node Type", "PE Purpose". Optional: "Status"/"Status J"/"Status K", "PE Category" (L).
Cancelled: if any Status column contains "Cancelled" (case-insensitive), the row is excluded from details and counted in the header.
Completed header:
VVM Status {DD Month YYYY} completed {completedCount}/{totalCount} ({totalCount} PE Category) {completedCount} PE's Completed, {cancelledCount} Cancelled
Then Node Type counts:
{NodeType}\t-{count}
Then:
*Key PE Details*
Numbered detail lines with "*Completed*" in italics.
  </pre>

  <script>
    /*** CONFIG: Set your Vercel API endpoint here ***/
    const API_URL = 'https://messageims.vercel.app/api/send-message'; // TODO: replace with your real URL

    /*** Helpers ***/
    function todayISO(){ const d=new Date(); return d.toISOString().slice(0,10); }
    function yesterdayISO(){ const d=new Date(); d.setDate(d.getDate()-1); return d.toISOString().slice(0,10); }
    function prettyDateFromISO(iso){
      if (!iso) return "";
      const d = new Date(iso);
      // Example: "23 December 2025"
      return d.toLocaleDateString(undefined,{ day:"2-digit", month:"long", year:"numeric" });
    }
    function csvToRows(text){
      const lines = text.trim().split(/\r?\n/);
      return lines.map(line => {
        if (line.includes('\t')) return line.split('\t');  // tab-delimited
        if (line.includes(','))  return line.split(',');   // comma-delimited
        if (line.includes(';'))  return line.split(';');   // semicolon-delimited
        return [line]; // fallback
      });
    }
    function unique(arr){ return Array.from(new Set(arr)); }

    /*** Core formatting tailored to your requested output ***/
    function formatOutput(rows, statusSelection) {
      if (!rows || rows.length === 0) return "No rows parsed.";
      const headers = rows[0].map(h=>h.trim());
      const idx = {}; headers.forEach((h,i)=>{ idx[h]=i; });

      // Required headers
      if (!("Node Type" in idx) || !("PE Purpose" in idx)) {
        return "Missing required headers: Node Type, PE Purpose";
      }

      // Optional columns
      const statusCols = ["Status","Status J","Status K"].filter(h=>h in idx).map(h=>idx[h]);
      const iNodeType = idx["Node Type"];
      const iPEPurpose = idx["PE Purpose"];

      // Cancelled?
      function isCancelled(r){ return statusCols.some(ci=>((r[ci]||"").toLowerCase().includes("cancelled"))); }
      const dataRows = rows.slice(1);
      const nonCancelled = dataRows.filter(r=>!isCancelled(r));

      const totalCount = nonCancelled.length;
      const completedCount = nonCancelled.filter(r=>statusCols.some(ci=>((r[ci]||"").toLowerCase().includes("completed")))).length;
      const cancelledCount = dataRows.length - nonCancelled.length;

      // Auto date
      const dateInput = document.getElementById("dateInput");
      let selectedDateISO = dateInput.value;
      if (!selectedDateISO) {
        if (statusSelection === "Completed") selectedDateISO = yesterdayISO();
        else if (statusSelection === "Planned Tonight") selectedDateISO = todayISO();
      }
      const prettyDate = prettyDateFromISO(selectedDateISO);

      // Build NodeType counts from non-cancelled rows
      const nodeTypeCounts = {};
      nonCancelled.forEach(r => {
        const nt = (r[iNodeType] || "").trim() || "(Unknown)";
        nodeTypeCounts[nt] = (nodeTypeCounts[nt] || 0) + 1;
      });
      // Convert to sorted lines "NAME\t-COUNT"
      const ntLines = Object.entries(nodeTypeCounts)
        .sort((a,b) => a[0].localeCompare(b[0]))  // alphabetical; change if you want by count
        .map(([name,count]) => `${name}\t-${count}`);

      // Key PE Details (numbered, italic Completed)
      const detailLines = nonCancelled.map((r, idxRow) => {
        const purpose = (r[iPEPurpose] || "").trim();
        const dispStatus = statusSelection === "Completed" ? "*Completed*" : (statusSelection || "");
        return `${idxRow+1}-\t${purpose}\t---\t${dispStatus}`;
      });

      // Header
      let headerText = "";
      if (statusSelection === "Completed") {
        headerText =
          `VVM Status ${prettyDate} completed ${completedCount}/${totalCount} ` +
          `(${totalCount} PE Category) ${completedCount} PE's Completed, ${cancelledCount} Cancelled\n\n`;
      } else if (statusSelection === "Planned Tonight") {
        headerText = `Tonight Planned IMS activities ${prettyDate}\n\n`;
      } else {
        headerText = `IMS activities ${prettyDate}\n\n`;
      }

      // Assemble final text per your format
      const nodeTypesBlock = ntLines.join("\n") + (ntLines.length ? "\n\n" : "");
      const keyHeader = `*Key PE Details*\n\n`;
      const detailsBlock = detailLines.join("\n");

      return headerText + nodeTypesBlock + keyHeader + detailsBlock;
    }

    /*** Wiring ***/
    const formattedOutputEl = document.getElementById("formattedOutput");
    const statusSelectEl = document.getElementById("statusSelect");
    let parsedRows = [];

    function render(){
      const statusSel = statusSelectEl.value || "";
      const text = formatOutput(parsedRows, statusSel);
      formattedOutputEl.textContent = text;
    }

    document.getElementById("parseTextBtn").addEventListener("click", ()=>{
      const raw = document.getElementById("gridText").value||"";
      if (!raw.trim()) { formattedOutputEl.textContent = "Paste grid text first."; return; }
      parsedRows = csvToRows(raw);
      render();
    });

    document.getElementById("parseFileBtn").addEventListener("click", async ()=>{
      const fileEl = document.getElementById("fileInput");
      const file = fileEl.files && fileEl.files[0];
      if (!file) { formattedOutputEl.textContent = "Select a file first."; return; }
      const text = await file.text(); // supports CSV/TSV/TXT
      parsedRows = csvToRows(text);
      render();
    });

    document.getElementById("clearBtn").addEventListener("click", ()=>{
      document.getElementById("gridText").value = "";
      document.getElementById("fileInput").value = "";
      parsedRows = [];
      formattedOutputEl.textContent = "";
    });

    statusSelectEl.addEventListener("change", render);
    document.getElementById("dateInput").addEventListener("change", render);

    // Copy / download
    document.getElementById("copyBtn").addEventListener("click", async ()=>{
      const text = formattedOutputEl.textContent||"";
      try { await navigator.clipboard.writeText(text); alert("Output copied to clipboard."); } catch(e){ alert("Copy failed: "+e.message); }
    });
    function download(filename, mime, content){
      const a=document.createElement("a");
      a.href=URL.createObjectURL(new Blob([content],{type:mime}));
      a.download=filename;
      document.body.appendChild(a); a.click(); a.remove();
    }
    document.getElementById("downloadTxtBtn").addEventListener("click", ()=>{
      download("IMS_Activities_Formatted.txt","text/plain", formattedOutputEl.textContent||"");
    });
    document.getElementById("downloadHtmlBtn").addEventListener("click", ()=>{
      const text=formattedOutputEl.textContent||"";
      const html=`<!DOCTYPE html><html><head><meta charset="utf-8"><title>IMS Output</title></head><body><pre>${escapeHtml(text)}</pre></body></html>`;
      download("IMS_Activities_Formatted.html","text/html", html);
    });
    function escapeHtml(s){
      return (s||"").replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
    }

    // Send to WhatsApp via Vercel endpoint
    document.getElementById('sendWhatsAppBtn').addEventListener('click', async () => {
      const to = (document.getElementById('waNumber').value || '').trim();
      const body = document.getElementById('formattedOutput').textContent || '';
      if (!to || !body) { alert('Enter recipient and generate output first.'); return; }

      try {
        const resp = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ channel: 'whatsapp_twilio', to, body })
        });
        const data = await resp.json();
        if (!resp.ok) throw new Error(data.error || 'Failed to send');
        alert(`WhatsApp queued: ${data.id || 'OK'}`);
      } catch (e) {
        alert(`Send failed: ${e.message}`);
      }
    });

    // Initialize defaults
    document.getElementById("dateInput").value = todayISO();
  </script>
</body>
</html>
